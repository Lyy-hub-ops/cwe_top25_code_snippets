static char *get_reloc_name(RCore *r, RBinReloc *reloc, ut64 addr) {
	char *reloc_name = NULL;
	char *demangled_name = NULL;
	const char *lang = r_config_get (r->config, "bin.lang");
	int bin_demangle = r_config_get_i (r->config, "bin.demangle");
	bool keep_lib = r_config_get_i (r->config, "bin.demangle.libs");
	if (reloc->import && reloc->import->name) {
		if (bin_demangle) {
			demangled_name = r_bin_demangle (r->bin->cur, lang, reloc->import->name, addr, keep_lib);
		}
		reloc_name = sdb_fmt ("reloc.%s_%d", demangled_name ? demangled_name : reloc->import->name,
				      (int)(addr & 0xff));
		if (!reloc_name) {
			free (demangled_name);
			return NULL;
		}
		r_str_replace_char (reloc_name, '$', '_');
	} else if (reloc->symbol && reloc->symbol->name) {
		if (bin_demangle) {
			demangled_name = r_bin_demangle (r->bin->cur, lang, reloc->symbol->name, addr, keep_lib);
		}
		reloc_name = sdb_fmt ("reloc.%s_%d", demangled_name ? demangled_name : reloc->symbol->name,
				      (int)(addr & 0xff));
		if (!reloc_name) {
			free (demangled_name);
			return NULL;
		}
		r_str_replace_char (reloc_name, '$', '_');
	} else if (reloc->is_ifunc) {
		// addend is the function pointer for the resolving ifunc
		reloc_name = sdb_fmt ("reloc.ifunc_%"PFMT64x, reloc->addend);
	} else {
		// TODO(eddyb) implement constant relocs.
	}
	free (demangled_name);
	return reloc_name;
}