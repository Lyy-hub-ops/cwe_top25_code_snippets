Image::Indexed **Image::Indexed::separate() {
  assert(getNcols()>=1);
  unsigned char ncols1=getNcols()-1;
  signed nncols=getNcols()-(transp==-1 ? 0 : 1);
  register unsigned char curcol;
  Indexed **ret=new Indexed*[nncols+1], **curimg=ret;
  Image::Sampled::dimen_t htc;
  assert(cpp==1);
  slen_t wdcpp=wd/* *cpp*/;
  register unsigned char *p;
  char *to, *toend;
  register unsigned int i;

  ret[nncols]=(Indexed*)NULLP;
  to8();
  for (curcol=0; curcol<=ncols1; curcol++) {
    if (transp==(signed int)curcol) continue;
    curimg[0]=new Indexed(wd, ht, /*ncols:*/2, /*bpc:*/1);
    memcpy(curimg[0]->headp, headp+3*curcol, 3); /* copy the color value */
    curimg[0]->setTransp(1);
    to=curimg[0]->rowbeg; p=(unsigned char*)rowbeg;
    htc=ht; while (htc--!=0) {
      toend=to+((wdcpp+7)>>3);
      while (to!=toend) {
        i =(*p++!=curcol)<<7; i|=(*p++!=curcol)<<6;
        i|=(*p++!=curcol)<<5; i|=(*p++!=curcol)<<4;
        i|=(*p++!=curcol)<<3; i|=(*p++!=curcol)<<2;
        i|=(*p++!=curcol)<<1; i|=(*p++!=curcol);
        *to++=i;
      }
      if (0!=(wdcpp&7)) p+=(wdcpp&7)-8; /* negative */
    }
    curimg++;
  }
  assert(curimg==ret+nncols);
  return ret;
}