static ssize_t _nhc_ipv6_encode_snip(gnrc_pktsnip_t *pkt,
                                     const gnrc_netif_hdr_t *netif_hdr,
                                     gnrc_netif_t *iface,
                                     uint8_t *nhc_data,
                                     uint8_t *nh)
{
    gnrc_pktsnip_t *hdr = pkt->next->next;
    ssize_t nhc_len = 1;    /* skip over NHC header */
    size_t tmp;
    uint8_t new_nh = ((ipv6_hdr_t *)hdr->data)->nh;

    assert(hdr->size >= sizeof(ipv6_hdr_t));
    /* Set IPv6 extension compression header type
     * (see https://tools.ietf.org/html/rfc6282#section-4.2). */
    nhc_data[0] = NHC_IPV6_EXT_ID;
    if (_compressible_nh(new_nh)) {
        nhc_data[0] |= NHC_IPV6_EXT_NH;
    }
    else {
        nhc_data[nhc_len++] = new_nh;
    }
    /* save to cast as result is max 40 */
    tmp = (ssize_t)_iphc_ipv6_encode(hdr, netif_hdr, iface, &nhc_data[nhc_len]);
    if (tmp == 0) {
        DEBUG("6lo iphc: error encoding IPv6 header\n");
        return -1;
    }
    nhc_len += tmp;
    /* remove encapsulated IPv6 header */
    if (!_remove_header(pkt, hdr, sizeof(ipv6_hdr_t))) {
        return -1;
    }
    *nh = new_nh;
    return nhc_len;
}