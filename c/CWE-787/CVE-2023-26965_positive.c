static int loadImage(TIFF *in, struct image_data *image, struct dump_opts *dump,
                     unsigned char **read_ptr)
{
    uint32_t i;
    float xres = 0.0, yres = 0.0;
    uint32_t nstrips = 0, ntiles = 0;
    uint16_t planar = 0;
    uint16_t bps = 0, spp = 0, res_unit = 0;
    uint16_t orientation = 0;
    uint16_t input_compression = 0, input_photometric = 0;
    uint16_t subsampling_horiz, subsampling_vert;
    uint32_t width = 0, length = 0;
    tmsize_t stsize = 0, tlsize = 0, buffsize = 0;
    tmsize_t scanlinesize = 0;
    uint32_t tw = 0, tl = 0; /* Tile width and length */
    tmsize_t tile_rowsize = 0;
    unsigned char *read_buff = NULL;
    unsigned char *new_buff = NULL;
    int readunit = 0;
    static tmsize_t prev_readsize = 0;

    TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);
    TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);
    TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
    TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
    if (!TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
        TIFFError("loadImage", "Image lacks Photometric interpretation tag");
    if (!TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width))
        TIFFError("loadimage", "Image lacks image width tag");
    if (!TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))
        TIFFError("loadimage", "Image lacks image length tag");
    TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);
    TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);
    if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))
        res_unit = RESUNIT_INCH;
    if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))
        input_compression = COMPRESSION_NONE;

#ifdef DEBUG2
    char compressionid[16];

    switch (input_compression)
    {
        case COMPRESSION_NONE: /* 1  dump mode */
            strcpy(compressionid, "None/dump");
            break;
        case COMPRESSION_CCITTRLE: /* 2 CCITT modified Huffman RLE */
            strcpy(compressionid, "Huffman RLE");
            break;
        case COMPRESSION_CCITTFAX3: /* 3 CCITT Group 3 fax encoding */
            strcpy(compressionid, "Group3 Fax");
            break;
        case COMPRESSION_CCITTFAX4: /* 4 CCITT Group 4 fax encoding */
            strcpy(compressionid, "Group4 Fax");
            break;
        case COMPRESSION_LZW: /* 5 Lempel-Ziv  & Welch */
            strcpy(compressionid, "LZW");
            break;
        case COMPRESSION_OJPEG: /* 6 !6.0 JPEG */
            strcpy(compressionid, "Old Jpeg");
            break;
        case COMPRESSION_JPEG: /* 7 %JPEG DCT compression */
            strcpy(compressionid, "New Jpeg");
            break;
        case COMPRESSION_NEXT: /* 32766 NeXT 2-bit RLE */
            strcpy(compressionid, "Next RLE");
            break;
        case COMPRESSION_CCITTRLEW: /* 32771 #1 w/ word alignment */
            strcpy(compressionid, "CITTRLEW");
            break;
        case COMPRESSION_PACKBITS: /* 32773 Macintosh RLE */
            strcpy(compressionid, "Mac Packbits");
            break;
        case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */
            strcpy(compressionid, "Thunderscan");
            break;
        case COMPRESSION_IT8CTPAD: /* 32895 IT8 CT w/padding */
            strcpy(compressionid, "IT8 padded");
            break;
        case COMPRESSION_IT8LW: /* 32896 IT8 Linework RLE */
            strcpy(compressionid, "IT8 RLE");
            break;
        case COMPRESSION_IT8MP: /* 32897 IT8 Monochrome picture */
            strcpy(compressionid, "IT8 mono");
            break;
        case COMPRESSION_IT8BL: /* 32898 IT8 Binary line art */
            strcpy(compressionid, "IT8 lineart");
            break;
        case COMPRESSION_PIXARFILM: /* 32908 Pixar companded 10bit LZW */
            strcpy(compressionid, "Pixar 10 bit");
            break;
        case COMPRESSION_PIXARLOG: /* 32909 Pixar companded 11bit ZIP */
            strcpy(compressionid, "Pixar 11bit");
            break;
        case COMPRESSION_DEFLATE: /* 32946 Deflate compression */
            strcpy(compressionid, "Deflate");
            break;
        case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */
            strcpy(compressionid, "Adobe deflate");
            break;
        default:
            strcpy(compressionid, "None/unknown");
            break;
    }
    TIFFError("loadImage", "Input compression %s", compressionid);
#endif

    scanlinesize = TIFFScanlineSize(in);
    image->bps = bps;
    image->spp = spp;
    image->planar = planar;
    image->width = width;
    image->length = length;
    image->xres = xres;
    image->yres = yres;
    image->res_unit = res_unit;
    image->compression = input_compression;
    image->photometric = input_photometric;
#ifdef DEBUG2
    char photometricid[12];

    switch (input_photometric)
    {
        case PHOTOMETRIC_MINISWHITE:
            strcpy(photometricid, "MinIsWhite");
            break;
        case PHOTOMETRIC_MINISBLACK:
            strcpy(photometricid, "MinIsBlack");
            break;
        case PHOTOMETRIC_RGB:
            strcpy(photometricid, "RGB");
            break;
        case PHOTOMETRIC_PALETTE:
            strcpy(photometricid, "Palette");
            break;
        case PHOTOMETRIC_MASK:
            strcpy(photometricid, "Mask");
            break;
        case PHOTOMETRIC_SEPARATED:
            strcpy(photometricid, "Separated");
            break;
        case PHOTOMETRIC_YCBCR:
            strcpy(photometricid, "YCBCR");
            break;
        case PHOTOMETRIC_CIELAB:
            strcpy(photometricid, "CIELab");
            break;
        case PHOTOMETRIC_ICCLAB:
            strcpy(photometricid, "ICCLab");
            break;
        case PHOTOMETRIC_ITULAB:
            strcpy(photometricid, "ITULab");
            break;
        case PHOTOMETRIC_LOGL:
            strcpy(photometricid, "LogL");
            break;
        case PHOTOMETRIC_LOGLUV:
            strcpy(photometricid, "LOGLuv");
            break;
        default:
            strcpy(photometricid, "Unknown");
            break;
    }
    TIFFError("loadImage", "Input photometric interpretation %s",
              photometricid);

#endif
    image->orientation = orientation;
    switch (orientation)
    {
        case 0:
        case ORIENTATION_TOPLEFT:
            image->adjustments = 0;
            break;
        case ORIENTATION_TOPRIGHT:
            image->adjustments = MIRROR_HORIZ;
            break;
        case ORIENTATION_BOTRIGHT:
            image->adjustments = ROTATECW_180;
            break;
        case ORIENTATION_BOTLEFT:
            image->adjustments = MIRROR_VERT;
            break;
        case ORIENTATION_LEFTTOP:
            image->adjustments = MIRROR_VERT | ROTATECW_90;
            break;
        case ORIENTATION_RIGHTTOP:
            image->adjustments = ROTATECW_90;
            break;
        case ORIENTATION_RIGHTBOT:
            image->adjustments = MIRROR_VERT | ROTATECW_270;
            break;
        case ORIENTATION_LEFTBOT:
            image->adjustments = ROTATECW_270;
            break;
        default:
            image->adjustments = 0;
            image->orientation = ORIENTATION_TOPLEFT;
    }

    if ((bps == 0) || (spp == 0))
    {
        TIFFError("loadImage",
                  "Invalid samples per pixel (%" PRIu16
                  ") or bits per sample (%" PRIu16 ")",
                  spp, bps);
        return (-1);
    }

    if (TIFFIsTiled(in))
    {
        readunit = TILE;
        tlsize = TIFFTileSize(in);
        ntiles = TIFFNumberOfTiles(in);
        TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
        TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);

        tile_rowsize = TIFFTileRowSize(in);
        if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)
        {
            TIFFError("loadImage",
                      "File appears to be tiled, but the number of tiles, tile "
                      "size, or tile rowsize is zero.");
            exit(EXIT_FAILURE);
        }
        if (ntiles != 0 && tlsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / ntiles))
        {
            TIFFError("loadImage",
                      "Integer overflow when calculating buffer size");
            exit(EXIT_FAILURE);
        }
        buffsize = tlsize * ntiles;

        if (tl != 0 && ntiles != 0 &&
            tile_rowsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / tl / ntiles))
        {
            TIFFError("loadImage",
                      "Integer overflow when calculating buffer size");
            exit(EXIT_FAILURE);
        }
        if (buffsize < (tmsize_t)(ntiles * tl * tile_rowsize))
        {
            buffsize = ntiles * tl * tile_rowsize;

#ifdef DEBUG2
            TIFFError("loadImage",
                      "Tilesize %" PRIu32 " is too small, using ntiles * "
                      "tilelength * tilerowsize %" PRIu32,
                      tlsize, buffsize);
#endif
        }

        if (dump->infile != NULL)
            dump_info(dump->infile, dump->format, "",
                      "Tilesize: %" TIFF_SSIZE_FORMAT
                      ", Number of Tiles: %" PRIu32
                      ", Tile row size: %" TIFF_SSIZE_FORMAT,
                      tlsize, ntiles, tile_rowsize);
    }
    else
    {
        tmsize_t buffsize_check;
        readunit = STRIP;
        TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
        stsize = TIFFStripSize(in);
        nstrips = TIFFNumberOfStrips(in);
        if (nstrips == 0 || stsize == 0)
        {
            TIFFError("loadImage", "File appears to be striped, but the number "
                                   "of stipes or stripe size is zero.");
            exit(EXIT_FAILURE);
        }

        if (nstrips != 0 && stsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / nstrips))
        {
            TIFFError("loadImage",
                      "Integer overflow when calculating buffer size");
            exit(EXIT_FAILURE);
        }
        buffsize = stsize * nstrips;
        /* The buffsize_check and the possible adaptation of buffsize
         * has to account also for padding of each line to a byte boundary.
         * This is assumed by mirrorImage() and rotateImage().
         * Furthermore, functions like extractContigSamplesShifted32bits()
         * need a buffer, which is at least 3 bytes larger than the actual
         * image. Otherwise buffer-overflow might occur there.
         */
        if ((spp != 0 && bps != 0 &&
             width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) ||
            (width != 0 && spp != 0 && bps != 0 &&
             length > (tmsize_t)(TIFF_TMSIZE_T_MAX /
                                 (uint32_t)(((width * spp * bps) + 7) / 8))))
        {
            TIFFError("loadImage", "Integer overflow detected.");
            exit(EXIT_FAILURE);
        }
        buffsize_check =
            (tmsize_t)length * (uint32_t)(((width * spp * bps) + 7) / 8);
        if (buffsize < buffsize_check)
        {
            buffsize = buffsize_check;
#ifdef DEBUG2
            TIFFError("loadImage",
                      "Stripsize %" PRIu32 " is too small, using imagelength * "
                      "width * spp * bps / 8 = %" PRIu32,
                      stsize, (unsigned long)buffsize);
#endif
        }

        if (dump->infile != NULL)
            dump_info(dump->infile, dump->format, "",
                      "Stripsize: %" TIFF_SSIZE_FORMAT
                      ", Number of Strips: %" PRIu32
                      ", Rows per Strip: %" PRIu32
                      ", Scanline size: %" TIFF_SSIZE_FORMAT,
                      stsize, nstrips, rowsperstrip, scanlinesize);
    }

    if (input_compression == COMPRESSION_JPEG)
    { /* Force conversion to RGB */
        jpegcolormode = JPEGCOLORMODE_RGB;
        TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
    }
    /* The clause up to the read statement is taken from Tom Lane's tiffcp patch
     */
    else
    { /* Otherwise, can't handle subsampled input */
        if (input_photometric == PHOTOMETRIC_YCBCR)
        {
            TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
                                  &subsampling_horiz, &subsampling_vert);
            if (subsampling_horiz != 1 || subsampling_vert != 1)
            {
                TIFFError("loadImage",
                          "Can't copy/convert subsampled image with "
                          "subsampling %" PRIu16 " horiz %" PRIu16 " vert",
                          subsampling_horiz, subsampling_vert);
                return (-1);
            }
        }
    }

    read_buff = *read_ptr;
    /* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */
    /* outside buffer */
    if (!read_buff)
    {
        if (buffsize > 0xFFFFFFFFU - 3)
        {
            TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
            return (-1);
        }
        read_buff =
            (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);
    }
    else
    {
        if (prev_readsize < buffsize)
        {
            if (buffsize > 0xFFFFFFFFU - 3)
            {
                TIFFError("loadImage",
                          "Unable to allocate/reallocate read buffer");
                return (-1);
            }
            new_buff =
                _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES);
            if (!new_buff)
            {
                free(read_buff);
                read_buff = (unsigned char *)limitMalloc(
                    buffsize + NUM_BUFF_OVERSIZE_BYTES);
            }
            else
                read_buff = new_buff;
        }
    }
    if (!read_buff)
    {
        TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
        return (-1);
    }

    read_buff[buffsize] = 0;
    read_buff[buffsize + 1] = 0;
    read_buff[buffsize + 2] = 0;

    prev_readsize = buffsize;
    *read_ptr = read_buff;

    /* N.B. The read functions used copy separate plane data into a buffer as
     * interleaved samples rather than separate planes so the same logic works
     * to extract regions regardless of the way the data are organized in the
     * input file.
     */
    switch (readunit)
    {
        case STRIP:
            if (planar == PLANARCONFIG_CONTIG)
            {
                if (!(readContigStripsIntoBuffer(in, read_buff)))
                {
                    TIFFError("loadImage",
                              "Unable to read contiguous strips into buffer");
                    return (-1);
                }
            }
            else
            {
                if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width,
                                                   spp, dump)))
                {
                    TIFFError("loadImage",
                              "Unable to read separate strips into buffer");
                    return (-1);
                }
            }
            break;

        case TILE:
            if (planar == PLANARCONFIG_CONTIG)
            {
                if (!(readContigTilesIntoBuffer(in, read_buff, length, width,
                                                tw, tl, spp, bps)))
                {
                    TIFFError("loadImage",
                              "Unable to read contiguous tiles into buffer");
                    return (-1);
                }
            }
            else
            {
                if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width,
                                                  tw, tl, spp, bps)))
                {
                    TIFFError("loadImage",
                              "Unable to read separate tiles into buffer");
                    return (-1);
                }
            }
            break;
        default:
            TIFFError("loadImage", "Unsupported image file format");
            return (-1);
            break;
    }
    if ((dump->infile != NULL) && (dump->level == 2))
    {
        dump_info(dump->infile, dump->format, "loadImage",
                  "Image width %" PRIu32 ", length %" PRIu32
                  ", Raw image data, %4" TIFF_SSIZE_FORMAT " bytes",
                  width, length, buffsize);
        dump_info(dump->infile, dump->format, "",
                  "Bits per sample %" PRIu16 ", Samples per pixel %" PRIu16,
                  bps, spp);

        if ((uint64_t)scanlinesize > 0x0ffffffffULL)
        {
            dump_info(
                dump->infile, dump->format, "loadImage",
                "Attention: scanlinesize %" PRIu64
                " is larger than UINT32_MAX.\nFollowing dump might be wrong.",
                (uint64_t)scanlinesize);
        }
        for (i = 0; i < length; i++)
            dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize,
                        i, read_buff + (i * scanlinesize));
    }
    return (0);
}