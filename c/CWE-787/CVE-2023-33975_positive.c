static int _rbuf_add(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,
                     size_t offset, unsigned page)
{
    union {
        gnrc_sixlowpan_frag_rb_base_t *super;
        gnrc_sixlowpan_frag_rb_t *rbuf;
        gnrc_sixlowpan_frag_vrb_t *vrb;
    } entry;
    const uint8_t *src = gnrc_netif_hdr_get_src_addr(netif_hdr);
    const uint8_t *dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);
    uint8_t *data = NULL;
    size_t frag_size = 0;   /* assign 0, otherwise cppcheck complains ;-) */
    int res;
    uint16_t datagram_size;
    uint16_t datagram_tag;

    /* check if provided offset is the same as in fragment */
    assert(_valid_offset(pkt, offset));
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG) && sixlowpan_frag_is(pkt->data)) {
        data = _6lo_frag_payload(pkt);
        frag_size = _6lo_frag_size(pkt, offset, data);
        if (frag_size == 0) {
            DEBUG("6lo rbuf: integer underflow detected.\n");
            gnrc_pktbuf_release(pkt);
            return RBUF_ADD_ERROR;
        }
        datagram_size = sixlowpan_frag_datagram_size(pkt->data);
        datagram_tag = sixlowpan_frag_datagram_tag(pkt->data);
    }
    else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&
             sixlowpan_sfr_rfrag_is(pkt->data)) {
        sixlowpan_sfr_rfrag_t *rfrag = pkt->data;

        data = _6lo_sfr_payload(pkt);
        frag_size = _6lo_sfr_frag_size(pkt);
        /* offset doubles as datagram size in RFRAG header when sequence number
         * is 0 */
        datagram_size = _6lo_sfr_datagram_size(pkt, offset);
        datagram_tag = rfrag->base.tag;
    }
    else {
        /* either one of the if branches above was taken */
        assert(data != NULL);
        gnrc_pktbuf_release(pkt);
        return RBUF_ADD_ERROR;
    }

    gnrc_sixlowpan_frag_rb_gc();
    /* only check VRB for subsequent frags, first frags create and not get VRB
     * entries below */
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&
        (offset > 0) &&
        sixlowpan_frag_n_is(pkt->data) &&
        (entry.vrb = gnrc_sixlowpan_frag_vrb_get(src, netif_hdr->src_l2addr_len,
                                                 datagram_tag)) != NULL) {
        DEBUG("6lo rbuf minfwd: VRB entry found, trying to forward\n");
        switch (_check_fragments(entry.super, frag_size, offset)) {
            case RBUF_ADD_REPEAT:
                DEBUG("6lo rbuf minfwd: overlap found; dropping VRB\n");
                gnrc_sixlowpan_frag_vrb_rm(entry.vrb);
                /* we don't repeat for VRB */
                gnrc_pktbuf_release(pkt);
                return RBUF_ADD_ERROR;
            case RBUF_ADD_DUPLICATE:
                DEBUG("6lo rbuf minfwd: not forwarding duplicate\n");
                gnrc_pktbuf_release(pkt);
                return RBUF_ADD_FORWARDED;
            default:
                break;
        }
        res = RBUF_ADD_ERROR;
        if (_rbuf_update_ints(entry.super, offset, frag_size)) {
            DEBUG("6lo rbuf minfwd: trying to forward fragment\n");
            entry.super->current_size += (uint16_t)frag_size;
            if (_forward_frag(pkt, sizeof(sixlowpan_frag_n_t), entry.vrb,
                              page) < 0) {
                DEBUG("6lo rbuf minfwd: unable to forward fragment\n");
                return RBUF_ADD_ERROR;
            }
            res = RBUF_ADD_FORWARDED;
        }
        return res;
    }
    else if ((res = _rbuf_get(src, netif_hdr->src_l2addr_len,
                              dst, netif_hdr->dst_l2addr_len,
                              datagram_size, datagram_tag, page)) < 0) {
        DEBUG("6lo rbuf: reassembly buffer full.\n");
        gnrc_pktbuf_release(pkt);
        return RBUF_ADD_ERROR;
    }
    entry.rbuf = &rbuf[res];
#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)
    offset += entry.rbuf->offset_diff;
#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */
    if ((offset + frag_size) > entry.super->datagram_size) {
        DEBUG("6lo rfrag: fragment too big for resulting datagram, discarding datagram\n");
        gnrc_pktbuf_release(entry.rbuf->pkt);
        gnrc_pktbuf_release(pkt);
        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);
        return RBUF_ADD_ERROR;
    }

    switch (_check_fragments(entry.super, frag_size, offset)) {
        case RBUF_ADD_REPEAT:
            DEBUG("6lo rfrag: overlapping intervals, discarding datagram\n");
            gnrc_pktbuf_release(entry.rbuf->pkt);
            gnrc_sixlowpan_frag_rb_remove(entry.rbuf);
            return RBUF_ADD_REPEAT;
        case RBUF_ADD_DUPLICATE:
            gnrc_pktbuf_release(pkt);
            return res;
        default:
            break;
    }

    if (_rbuf_update_ints(entry.super, offset, frag_size)) {
        DEBUG("6lo rbuf: add fragment data\n");
        entry.super->current_size += (uint16_t)frag_size;
        if (offset == 0) {
            if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC) &&
                sixlowpan_iphc_is(data)) {
                DEBUG("6lo rbuf: detected IPHC header.\n");
                gnrc_pktsnip_t *frag_hdr = _mark_frag_hdr(pkt);

                if (frag_hdr == NULL) {
                    DEBUG("6lo rbuf: unable to mark fragment header. "
                          "aborting reassembly.\n");
                    gnrc_pktbuf_release(entry.rbuf->pkt);
                    gnrc_pktbuf_release(pkt);
                    gnrc_sixlowpan_frag_rb_remove(entry.rbuf);
                    return RBUF_ADD_ERROR;
                }
                else {
                    DEBUG("6lo rbuf: handing over to IPHC reception.\n");
                    /* `pkt` released in IPHC */
                    gnrc_sixlowpan_iphc_recv(pkt, entry.rbuf, 0);
                    /* check if entry was deleted in IPHC (error case) */
                    if (gnrc_sixlowpan_frag_rb_entry_empty(entry.rbuf)) {
                        res = RBUF_ADD_ERROR;
                    }
                    return res;
                }
            }
            else if (data[0] == SIXLOWPAN_UNCOMP) {
                DEBUG("6lo rbuf: detected uncompressed datagram\n");
                data++;
                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&
                    /* only try minimal forwarding when fragment is the only
                     * fragment in reassembly buffer yet */
                    sixlowpan_frag_1_is(pkt->data) &&
                    (entry.super->current_size == frag_size)) {
                    gnrc_sixlowpan_frag_vrb_t *vrbe;
                    gnrc_pktsnip_t tmp = {
                        .data = data,
                        .size = frag_size,
                        .users = 1,
                    };

                    if (_check_hdr(&tmp, page) &&
                        (vrbe = gnrc_sixlowpan_frag_vrb_from_route(
                                    entry.super,
                                    gnrc_netif_hdr_get_netif(netif_hdr),
                                    &tmp))) {
                        _adapt_hdr(&tmp, page);
                        return _forward_uncomp(pkt, rbuf, vrbe, page);
                    }
                }
                else if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&
                         sixlowpan_sfr_rfrag_is(pkt->data)) {
                    entry.super->datagram_size--;
                }
            }
        }
        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) ||
            IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)) {
            /* all cases to try forwarding with minfwd or SFR above failed so
             * just do normal reassembly. For the `minfwd` case however, we need
             * to resize `entry.rbuf->pkt`, since we kept the packet allocation
             * with fragment forwarding as minimal as possible in
             * `_rbuf_get()` */
            res = _rbuf_resize_for_reassembly(entry.rbuf);
            if (res == RBUF_ADD_ERROR) {
                gnrc_pktbuf_release(pkt);
                return res;
            }
        }
        memcpy(((uint8_t *)entry.rbuf->pkt->data) + offset, data,
               frag_size);
    }
    else {
        /* no space left in rbuf interval buffer*/
        gnrc_pktbuf_release(entry.rbuf->pkt);
        gnrc_sixlowpan_frag_rb_remove(entry.rbuf);
        res = RBUF_ADD_ERROR;
    }
    /* no errors and not consumed => release packet */
    gnrc_pktbuf_release(pkt);
    return res;
}