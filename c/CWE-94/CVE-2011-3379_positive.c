static void add_class_vars(zend_class_entry *ce, int statics, zval *return_value TSRMLS_DC)
{
	HashPosition pos;
	zend_property_info *prop_info;
	zval *prop, *prop_copy;
	char *key;
	uint key_len;
	ulong num_index;

	zend_hash_internal_pointer_reset_ex(&ce->properties_info, &pos);
	while (zend_hash_get_current_data_ex(&ce->properties_info, (void **) &prop_info, &pos) == SUCCESS) {
		zend_hash_get_current_key_ex(&ce->properties_info, &key, &key_len, &num_index, 0, &pos);
		zend_hash_move_forward_ex(&ce->properties_info, &pos);
		if (((prop_info->flags & ZEND_ACC_SHADOW) &&
		     prop_info->ce != EG(scope)) ||
		    ((prop_info->flags & ZEND_ACC_PROTECTED) &&
		     !zend_check_protected(prop_info->ce, EG(scope))) ||
		    ((prop_info->flags & ZEND_ACC_PRIVATE) &&
		      ce != EG(scope) &&
			  prop_info->ce != EG(scope))) {
			continue;
		}
		prop = NULL;
		if (prop_info->offset >= 0) {
			if (statics && (prop_info->flags & ZEND_ACC_STATIC) != 0) {
				prop = ce->default_static_members_table[prop_info->offset];
			} else if (!statics && (prop_info->flags & ZEND_ACC_STATIC) == 0) {
				prop = ce->default_properties_table[prop_info->offset];
 			}
		}
		if (!prop) {
			continue;
		}

		/* copy: enforce read only access */
		ALLOC_ZVAL(prop_copy);
		*prop_copy = *prop;
		zval_copy_ctor(prop_copy);
		INIT_PZVAL(prop_copy);

		/* this is necessary to make it able to work with default array
		 * properties, returned to user */
		if (Z_TYPE_P(prop_copy) == IS_CONSTANT_ARRAY || (Z_TYPE_P(prop_copy) & IS_CONSTANT_TYPE_MASK) == IS_CONSTANT) {
			zval_update_constant(&prop_copy, 0 TSRMLS_CC);
		}

		add_assoc_zval(return_value, key, prop_copy);
	}
}